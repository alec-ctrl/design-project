Index: src/org/alecs2023/designproject/Enemy_Blob.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.alecs2023.designproject;\n\npublic class Enemy_Blob extends Player{\n    /**\n     *\n     * @return how much damage this enemy does\n     */\n    public int Damage(){\n        return -1;\n    }\n\n    /**\n     * in case you hit a wall\n     */\n    public void bounce(){\n        this.velX *= -1;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/org/alecs2023/designproject/Enemy_Blob.java b/src/org/alecs2023/designproject/Enemy_Blob.java
--- a/src/org/alecs2023/designproject/Enemy_Blob.java	(revision 4279333957e134dfb023dc1192d2f9067d52f0fe)
+++ b/src/org/alecs2023/designproject/Enemy_Blob.java	(date 1620150225819)
@@ -1,6 +1,10 @@
 package org.alecs2023.designproject;
 
 public class Enemy_Blob extends Player{
+
+    Enemy_Blob(){
+        this.velX = 1;
+    }
     /**
      *
      * @return how much damage this enemy does
@@ -9,10 +13,5 @@
         return -1;
     }
 
-    /**
-     * in case you hit a wall
-     */
-    public void bounce(){
-        this.velX *= -1;
-    }
+
 }
Index: src/org/alecs2023/designproject/GameLogic.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.alecs2023.designproject;\n\nimport javafx.animation.AnimationTimer;\nimport javafx.scene.Scene;\nimport javafx.scene.canvas.Canvas;\nimport javafx.scene.canvas.GraphicsContext;\nimport javafx.scene.paint.Color;\n\nimport java.util.ArrayList;\n\npublic class GameLogic {\n    private Player player;\n    private Maze maze;\n    private ArrayList<Enemy_Blob> blobs;\n    private double width, height;\n    private GameTimer gameTimer;\n    public static final double GAME_STEP_TIMER = 12;\n\n\n\n\n    public enum DIRECTION {\n        LEFT,\n        UP,\n        RIGHT,\n        DOWN,\n        GRAVITY,\n    }\n\n\n\n    public GameLogic(double width, double height){\n        gameTimer = new GameTimer();\n        player = new Player();\n        player.setWidth(10);\n        player.setColor(Color.BLACK);\n        maze = new Maze();\n        player.x = 200;\n        player.y = 400;\n        blobs = new ArrayList<>();\n        for(int i = 0; i < 5; i++){\n            Enemy_Blob blob = new Enemy_Blob();\n            blob.setWidth(10);\n            blob.setColor(Color.RED);\n            blob.x = 200;\n            blob.y = 200;\n            blobs.add(blob);\n        }\n\n\n\n    }\n\n    public void render(Canvas canvas){\n        width = canvas.getWidth();\n        height = canvas.getHeight();\n        player.render(canvas);\n        for (Enemy_Blob blob : blobs) {\n            blob.render(canvas);\n        }\n        maze.render_Maze1(canvas);\n    }\n    public void stop_player(){\n        player.velX = 0;\n        player.velY = 0;\n    }\n    public void applyForce(DIRECTION direction){\n        if(direction == DIRECTION.LEFT){\n            player.velX = 0;\n            player.velX -= 5;\n        }\n        if(direction == DIRECTION.RIGHT){\n            player.velX = 0;\n            player.velX += 5;\n        }\n        if(direction == DIRECTION.UP){\n            //Putting it behind this requirement so you can't jump more than once\n            if(!player.jump) {\n                player.jump = true;\n                player.base_height = player.y;\n                player.up = true;\n            }\n        }\n        if(direction == DIRECTION.DOWN){\n            player.velY = 0;\n            player.velY += 5;\n        }\n        if(direction == DIRECTION.GRAVITY){\n            player.gravity = !player.gravity;\n        }\n    }\n    /**\n     * Pause or unpause the game\n     * @param setPaused true to pause, false otherwise\n     */\n    public void pause(boolean setPaused ){\n        if( setPaused ){\n            gameTimer.stop();\n        }\n        else {\n            gameTimer.start();\n        }\n    }\n\n    private class GameTimer extends AnimationTimer {\n        // The last nanosecond\n        private long lastUpdate;\n\n        public GameTimer() {\n            lastUpdate = 0;\n        }\n\n        @Override\n        public void handle(long now) {\n\n\n            // Covert the time_elapsed from nanoseconds to milliseconds\n            long time_elaped = (now - lastUpdate) / 1000000;\n            if (time_elaped > GameLogic.GAME_STEP_TIMER) {\n                if (player.jump){\n\n                    if (player.y > player.base_height){\n                        player.jump = false;\n\n                    }else{\n                        player.jump((int) player.base_height, player);\n                    }\n                }\n\n                player.move();\n                maze.check_collisions(player );\n                maze.falling(player);\n                for(Enemy_Blob blob: blobs){\n                    maze.falling(blob);\n                    maze.check_collisions(blob);\n                }\n\n                lastUpdate = now;\n            }\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/org/alecs2023/designproject/GameLogic.java b/src/org/alecs2023/designproject/GameLogic.java
--- a/src/org/alecs2023/designproject/GameLogic.java	(revision 4279333957e134dfb023dc1192d2f9067d52f0fe)
+++ b/src/org/alecs2023/designproject/GameLogic.java	(date 1620168299429)
@@ -1,9 +1,7 @@
 package org.alecs2023.designproject;
 
 import javafx.animation.AnimationTimer;
-import javafx.scene.Scene;
 import javafx.scene.canvas.Canvas;
-import javafx.scene.canvas.GraphicsContext;
 import javafx.scene.paint.Color;
 
 import java.util.ArrayList;
@@ -30,11 +28,13 @@
 
 
     public GameLogic(double width, double height){
+
         gameTimer = new GameTimer();
         player = new Player();
         player.setWidth(10);
         player.setColor(Color.BLACK);
         maze = new Maze();
+        maze.save_Maze1(width,height);
         player.x = 200;
         player.y = 400;
         blobs = new ArrayList<>();
@@ -42,13 +42,10 @@
             Enemy_Blob blob = new Enemy_Blob();
             blob.setWidth(10);
             blob.setColor(Color.RED);
-            blob.x = 200;
-            blob.y = 200;
+            blob.x = 300 + 20 * i;
+            blob.y = 400;
             blobs.add(blob);
         }
-
-
-
     }
 
     public void render(Canvas canvas){
@@ -75,20 +72,86 @@
         }
         if(direction == DIRECTION.UP){
             //Putting it behind this requirement so you can't jump more than once
-            if(!player.jump) {
+            if(!player.jump && player.gravity ) {
                 player.jump = true;
                 player.base_height = player.y;
                 player.up = true;
             }
         }
         if(direction == DIRECTION.DOWN){
-            player.velY = 0;
-            player.velY += 5;
+            //TODO ONGROUND FUNCTION IS NOT WORKING
+            if(!player.jump && !player.gravity )  {
+                player.jump = true;
+                player.base_height = player.y;
+                player.down = true;
+            }
         }
         if(direction == DIRECTION.GRAVITY){
             player.gravity = !player.gravity;
+            for(Enemy_Blob blob : blobs){
+                blob.gravity = !blob.gravity;
+            }
+        }
+    }
+    private void collideBlob(Enemy_Blob blob){
+        //above bottom
+
+        if(player.y <= blob.y  &&
+                //below top
+                player.y + player.getWidth() >= blob.y - blob.getWidth() &&
+                //left of right side
+                player.x <= blob.x + blob.getWidth() &&
+                //right of left side
+                player.x + player.getWidth() >= blob.x
+        ) {
+            blob.bounce();
+            player.bounce();
+        }
+
+    }
+
+    /**
+     * keeping the player (or any ememy) on screen
+     * @param player any like enemy or the player
+     */
+    private void onScreen(Player player){
+        if (player.x <= 0){
+            player.x = 0;
+            if(player instanceof Enemy_Blob){
+                player.bounce();
+            }
+        }
+        if(player.x >= width) {
+            player.x = width - player.getWidth();
+            if(player instanceof Enemy_Blob){
+                player.bounce();
+            }
+        }
+        if (player.y <= 0){
+            player.y = 0;
+            if(!player.gravity){
+                //so you can jump
+                player.base_height = 0;
+                //so 'falling' method in Maze doesn't run after this
+                player.on_ground = true;
+                player.jump = false;
+            }
         }
+        if (player.y + player.getWidth() >= height){
+            player.y = height - player.getWidth();
+            if(player.gravity){
+                //so you can jump
+                player.base_height = height-player.getWidth();
+                //so 'falling' method in Maze doesn't run after this
+                player.on_ground = true;
+                player.jump = false;
+
+            }
+        }
+
     }
+
+
     /**
      * Pause or unpause the game
      * @param setPaused true to pause, false otherwise
@@ -119,20 +182,24 @@
             if (time_elaped > GameLogic.GAME_STEP_TIMER) {
                 if (player.jump){
 
-                    if (player.y > player.base_height){
-                        player.jump = false;
-
-                    }else{
-                        player.jump((int) player.base_height, player);
-                    }
+                    player.jump((int) player.base_height, player);
                 }
+
 
                 player.move();
-                maze.check_collisions(player );
+                maze.check_collisions(player);
+                onScreen(player);
+
                 maze.falling(player);
+
+
                 for(Enemy_Blob blob: blobs){
                     maze.falling(blob);
                     maze.check_collisions(blob);
+                    onScreen(blob);
+                    collideBlob(blob);
+                    blob.move();
+
                 }
 
                 lastUpdate = now;
Index: src/org/alecs2023/designproject/GameGUI.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.alecs2023.designproject;\n\nimport javafx.animation.AnimationTimer;\nimport javafx.geometry.Pos;\nimport javafx.scene.Parent;\nimport javafx.scene.canvas.Canvas;\nimport javafx.scene.canvas.GraphicsContext;\nimport javafx.scene.control.Label;\nimport javafx.scene.input.KeyCode;\nimport javafx.scene.input.KeyEvent;\nimport javafx.scene.layout.BorderPane;\nimport javafx.scene.layout.GridPane;\nimport javafx.scene.layout.HBox;\nimport javafx.scene.layout.Pane;\nimport javafx.scene.paint.Color;\nimport javafx.scene.text.Font;\n\npublic class GameGUI extends BorderPane {\n    private Canvas gameArea;\n    private AnimationTimer animTimer;\n    private GameLogic logic;\n    private HBox topBox;\n    private Label lifeNumberLabel;\n    private HBox livesBox;\n\n    public GameGUI(){\n\n        gameArea = new Canvas();\n        gameArea.heightProperty().bind(this.heightProperty());\n        gameArea.widthProperty().bind(this.widthProperty());\n\n        animTimer = new AnimTimer();\n\n\n        logic = new GameLogic(gameArea.getWidth(), gameArea.getHeight());\n\n        this.getChildren().add(gameArea);\n\n    }\n\n\n    /**\n     * Pause/unpause teh animation and game timer\n     *\n     * @param setAnimPause true to pause the animation timer\n     * @param setGamePause true to pause the game timer\n     */\n    public void pause(boolean setAnimPause, boolean setGamePause) {\n        this.pause(setAnimPause);\n        logic.pause(setGamePause);\n    }\n\n    /**\n     * Deal with key presses\n     *\n     * @param event the event to handle\n     */\n    public void handleKeyPress(KeyEvent event) {\n        if (event.getCode() == KeyCode.D) {\n            logic.applyForce(GameLogic.DIRECTION.RIGHT);\n        }\n        if (event.getCode() == KeyCode.S) {\n            logic.applyForce(GameLogic.DIRECTION.DOWN);\n        }\n        if (event.getCode() == KeyCode.A) {\n            logic.applyForce(GameLogic.DIRECTION.LEFT);\n        }\n        if (event.getCode() == KeyCode.W) {\n            logic.applyForce(GameLogic.DIRECTION.UP);\n        }\n        if (event.getCode() == KeyCode.SPACE) {\n            logic.applyForce(GameLogic.DIRECTION.GRAVITY);\n        }\n    }\n    public void handleKeyRelease(KeyEvent event){\n        logic.stop_player();\n    }\n    /**\n     * Runs once per frame and handles all the drawing of each frame\n     */\n    private class AnimTimer extends AnimationTimer {\n\n        @Override\n        public void handle(long now) {\n            GraphicsContext gc = gameArea.getGraphicsContext2D();\n            gc.clearRect(0, 0, gameArea.getWidth(), gameArea.getHeight());\n\n            logic.render(gameArea);\n        }\n    }\n    public void pause(boolean setAnimPause) {\n        if (setAnimPause) {\n            animTimer.stop();\n        } else {\n            animTimer.start();\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/org/alecs2023/designproject/GameGUI.java b/src/org/alecs2023/designproject/GameGUI.java
--- a/src/org/alecs2023/designproject/GameGUI.java	(revision 4279333957e134dfb023dc1192d2f9067d52f0fe)
+++ b/src/org/alecs2023/designproject/GameGUI.java	(date 1620158686591)
@@ -31,11 +31,13 @@
 
         animTimer = new AnimTimer();
 
+        //giving it the width and height of the canvas
+        logic = new GameLogic(500,500);
 
-        logic = new GameLogic(gameArea.getWidth(), gameArea.getHeight());
 
         this.getChildren().add(gameArea);
 
+
     }
 
 
@@ -85,6 +87,7 @@
             GraphicsContext gc = gameArea.getGraphicsContext2D();
             gc.clearRect(0, 0, gameArea.getWidth(), gameArea.getHeight());
 
+
             logic.render(gameArea);
         }
     }
Index: src/org/alecs2023/designproject/Player.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.alecs2023.designproject;\n\nimport javafx.geometry.Point2D;\nimport javafx.scene.canvas.Canvas;\nimport javafx.scene.canvas.GraphicsContext;\nimport javafx.scene.paint.Color;\n\npublic class Player {\n    private double width;\n    private Color color;\n    public boolean up = true;\n    public boolean jump;\n    public double base_height;\n    public double x, y;     //Center point of the square\n    public double velX, velY;\n    public boolean gravity = true;\n    public boolean on_ground;\n\n\n\n    private double[] boundX, boundY;\n    /**\n     * Creates a rectangle with a wdith of one\n     */\n    public Player(){\n        this(1);\n    }\n\n    /**\n     * Creates a square with a custom width (in pixels)\n     * @param width the width (in pixels) to set of the rectangle; Non-positives are reset to one\n     *  (add this comment before a non public method)(this is a constructor)\n     */\n    public Player( double width ){\n        color = Color.BLACK;\n        if (width <= 0){\n            width = 1;\n        }\n        this.width = width;\n\n        boundX = new double[2];\n        boundY = new double[2];\n    }\n\n    /**\n     * Set the width of this object.  A rectangle's width must be positive.\n     * @param width the new, positive, width of this object\n     * @return true if the width is set, false if width is not changed\n     */\n    public boolean setWidth(double width){\n        boolean rtn = false;\n        if(width > 0){\n            this.width = width;\n            rtn = true;\n        }\n        return rtn;\n    }\n\n    /**\n     * Get the current width of this object\n     * @return a positive width\n     */\n    public double getWidth(){\n        return this.width;\n    }\n\n    /**\n     * Sets the color of the ball\n     * @param c the new color of the ball (cannot be null)\n     * @return true if the color has changed, false otherwise\n     */\n    public boolean setColor( Color c ){\n        if(c == null){\n            return false;\n        }\n        this.color = c;\n        return true;\n    }\n\n    /**\n     * Get the current color of the ball\n     * @return the current color of the ball\n     */\n    public Color getColor(){\n        return this.color;\n    }\n\n\n    /**\n     * Move the ball along its trajectory vector\n     */\n    public void move(){\n\n        double moveVelX = this.velX;\n        double moveVelY = this.velY;\n\n        this.x += moveVelX;\n        this.y += moveVelY;\n\n    }\n\n    public boolean jump(int base_height, Player player){\n        int height = (int) (base_height - player.y );\n        int x = (int) (Math.sqrt(-height + 10)+3);\n        if (height > 70){\n            up = false;\n        }\n        if(up){\n            player.y -= ((((x+2)-3)*((x+2)-3))+10)/3;\n        }else{\n            player.y += ((((x+2)-3)*((x+2)-3))+10)/3;\n\n        }\n\n\n        if(player.y >= base_height){\n            player.y = base_height+1;\n\n\n            return false;\n        }\n        return true;\n\n    }\n\n    public void render( Canvas canvas ){\n\n        GraphicsContext gc = canvas.getGraphicsContext2D();\n        gc.setFill(this.color);\n        gc.fillRect(x, y, width, width );\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/org/alecs2023/designproject/Player.java b/src/org/alecs2023/designproject/Player.java
--- a/src/org/alecs2023/designproject/Player.java	(revision 4279333957e134dfb023dc1192d2f9067d52f0fe)
+++ b/src/org/alecs2023/designproject/Player.java	(date 1620169876582)
@@ -9,6 +9,7 @@
     private double width;
     private Color color;
     public boolean up = true;
+    public boolean down = false;
     public boolean jump;
     public double base_height;
     public double x, y;     //Center point of the square
@@ -99,28 +100,43 @@
 
     }
 
-    public boolean jump(int base_height, Player player){
+    public void jump(int base_height, Player player ){
         int height = (int) (base_height - player.y );
-        int x = (int) (Math.sqrt(-height + 10)+3);
+
+        int x = (int) (Math.sqrt(height)+9);
+
+
+
+
         if (height > 70){
-            up = false;
+                up = false;
+            }
+        if (height < -70) {
+            down = false;
+
         }
-        if(up){
-            player.y -= ((((x+2)-3)*((x+2)-3))+10)/3;
-        }else{
-            player.y += ((((x+2)-3)*((x+2)-3))+10)/3;
-
-        }
+            if(up) {
+
+                player.y -= ((x - 9) * (x - 9)) + 1 ;
+                System.out.println(x);
+                System.out.println(((x -9) * (x - 9)) );
+
+            } else if (gravity){
+                player.y += ((x -9) * (x - 9) + 10) ;
+            }
+            if(down) {
+                player.y += ((((x + 2) - 3) * ((x + 2) - 3)) + 10) / 3;
+            } else if (!gravity){
+                player.y -= ((((x + 2) - 3) * ((x + 2) - 3)) + 10) / 3;
+            }
 
 
-        if(player.y >= base_height){
-            player.y = base_height+1;
-
-
-            return false;
-        }
-        return true;
-
+    }
+    /**
+     * in case you hit a wall
+     */
+    public void bounce(){
+        this.velX *= -1;
     }
 
     public void render( Canvas canvas ){
@@ -129,5 +145,6 @@
         gc.setFill(this.color);
         gc.fillRect(x, y, width, width );
     }
+
 }
 
Index: src/org/alecs2023/designproject/Maze.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.alecs2023.designproject;\n\nimport javafx.scene.canvas.Canvas;\nimport javafx.scene.canvas.GraphicsContext;\nimport javafx.scene.paint.Color;\nimport javafx.scene.shape.Rectangle;\n\nimport java.util.ArrayList;\n\npublic class Maze {\n    private double width, height;\n    private ArrayList<Rectangle>  Maze1_walls = new ArrayList<Rectangle>();\n\n\n    public void render_Maze1(Canvas canvas) {\n        width = canvas.getWidth();\n        height = canvas.getHeight();\n        GraphicsContext gc = canvas.getGraphicsContext2D();\n        gc.setFill(Color.BLACK);\n        gc.fillRect(width / 2 + 20, height - 30, width / 2 - 20, 30);\n        Maze1_walls.add(new Rectangle(width / 2 + 20, height - 30, width / 2 - 20, 30));\n        gc.fillRect(0, height - 30, width / 2 - 20, 30);\n        Maze1_walls.add(new Rectangle(0, height - 30, width / 2 - 20, 30));\n        gc.fillRect(width / 3, height / 2 + 50, width / 2, 30);\n        Maze1_walls.add(new Rectangle(width / 3, height / 2 + 50, width / 2, 30));\n        gc.fillRect(0, height / 2, 30, height / 2);\n        Maze1_walls.add(new Rectangle(0, height / 2, 30, height / 2));\n        gc.fillRect(width - 30, height / 2 - 50, 30, height / 2 + 50);\n        Maze1_walls.add(new Rectangle(width - 30, height / 2 - 50, 30, height / 2 + 50));\n        gc.fillRect(width - 60, 3 * height / 4, 30, 10);\n        Maze1_walls.add(new Rectangle(width - 60, 3 * height / 4, 30, 10));\n        gc.fillRect(width / 2 - 30, height / 4, 30, 200);\n        Maze1_walls.add(new Rectangle(width / 2 - 30, height / 4, 30, 200));\n        gc.fillRect(width / 2, height / 4 + 100, 30, 10);\n        Maze1_walls.add(new Rectangle(width / 2, height / 4 + 100, 30, 10));\n        gc.fillRect(0, height / 4, 250, 30);\n        Maze1_walls.add(new Rectangle(0, height / 4, 250, 30));\n        gc.fillRect(2 * width / 3, height / 2 - 50, width / 2, 30);\n        Maze1_walls.add(new Rectangle(2 * width / 3, height / 2 - 50, width / 2, 30));\n        gc.fillRect(width / 2 + 100, height / 4 - 30, 30, 10);\n        Maze1_walls.add(new Rectangle(width / 2 + 100, height / 4 - 30, 30, 10));\n        gc.fillRect(width - 30, height / 4 - 30, 30, 10);\n        Maze1_walls.add(new Rectangle(width - 30, height / 4 - 30, 30, 10));\n    }\n\n    public void check_collisions(Player player) {\n        for (Rectangle maze1_wall : Maze1_walls) {\n            //checking for which direction the wall is, and changing the coordinates accordingly\n            //wall on left\n            if (player.y < maze1_wall.getY() + maze1_wall.getHeight() &&\n                    //below top\n                    player.y > maze1_wall.getY() &&\n                    //left of right side\n                    player.x < maze1_wall.getX() + maze1_wall.getWidth() &&\n                    //right of left side\n                    player.x > maze1_wall.getX() &&\n                    player.y + player.getWidth() < maze1_wall.getY() + maze1_wall.getHeight() &&\n                    //below top\n                    player.y + player.getWidth() > maze1_wall.getY()){\n                player.x = maze1_wall.getX() + maze1_wall.getWidth();\n\n\n            }\n\n            //wall right\n            if (player.y + player.getWidth() < maze1_wall.getY() + maze1_wall.getHeight() &&\n                    //below top\n                    player.y + player.getWidth() > maze1_wall.getY() &&\n                    //left of right side\n                    player.x + player.getWidth() < maze1_wall.getX() + maze1_wall.getWidth()&&\n                    //right of left side\n                    player.x + player.getWidth() > maze1_wall.getX() &&\n                    player.y < maze1_wall.getY() + maze1_wall.getHeight() &&\n                    //below top\n                    player.y > maze1_wall.getY()\n                    //left of right side\n\n            ){\n                player.x = maze1_wall.getX() - player.getWidth();\n\n            }\n            //bottom\n            if (player.x + player.getWidth() <= maze1_wall.getX() + maze1_wall.getWidth() &&\n                    //below top\n                    player.x + player.getWidth() >= maze1_wall.getX() &&\n                    //left of right side\n                    player.y + player.getWidth() < maze1_wall.getY() + maze1_wall.getHeight()&&\n                    //right of left side\n                    player.y + player.getWidth() > maze1_wall.getY() &&\n                    player.x <= maze1_wall.getX() + maze1_wall.getWidth() &&\n                    //below top\n                    player.x >= maze1_wall.getX()\n                //left of right side\n\n\n            ){\n                if(player.gravity){\n                    player.on_ground = true;\n                }\n                player.y = maze1_wall.getY() - player.getWidth();\n                player.jump = false;\n\n\n            }\n            //top\n            if (player.x + player.getWidth() <= maze1_wall.getX() + maze1_wall.getWidth() &&\n                    //below top\n                    player.x + player.getWidth() >= maze1_wall.getX() &&\n                    //left of right side\n                    player.y < maze1_wall.getY() + maze1_wall.getHeight()&&\n                    //right of left side\n                    player.y > maze1_wall.getY() &&\n                    player.x <= maze1_wall.getX() + maze1_wall.getWidth() &&\n                    //below top\n                    player.x >= maze1_wall.getX()\n                //left of right side\n\n            ){\n                if(!player.gravity){\n                    player.on_ground = true;\n\n                }\n                player.y = maze1_wall.getY() + maze1_wall.getHeight();\n\n            }\n            if(player.y == maze1_wall.getY() + maze1_wall.getHeight() && !player.gravity &&\n                    player.x < maze1_wall.getX() + maze1_wall.getWidth() &&\n                    //below top\n                    player.x > maze1_wall.getX() &&\n                    player.x + player.getWidth() < maze1_wall.getX() + maze1_wall.getWidth() &&\n                    //below top\n                    player.x + player.getWidth() > maze1_wall.getX()\n                //left of right side\n            ){\n                player.on_ground = true;\n\n            }\n            if(player.y + player.getWidth() == maze1_wall.getY() && player.gravity &&\n                    player.x < maze1_wall.getX() + maze1_wall.getWidth() &&\n                    //below top\n                    player.x > maze1_wall.getX() &&\n                    player.x + player.getWidth() < maze1_wall.getX() + maze1_wall.getWidth() &&\n                    //below top\n                    player.x + player.getWidth() > maze1_wall.getX()){\n                player.on_ground = true;\n\n            }\n\n\n        }\n    }\n\n    public void falling(Player player){\n\n        if(!player.on_ground && !player.jump && player.gravity){\n            player.y += 4;\n        } else if(!player.on_ground && !player.jump){\n            player.y -= 2;\n        }\n        player.on_ground = false;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/org/alecs2023/designproject/Maze.java b/src/org/alecs2023/designproject/Maze.java
--- a/src/org/alecs2023/designproject/Maze.java	(revision 4279333957e134dfb023dc1192d2f9067d52f0fe)
+++ b/src/org/alecs2023/designproject/Maze.java	(date 1620165640716)
@@ -9,151 +9,166 @@
 
 public class Maze {
     private double width, height;
-    private ArrayList<Rectangle>  Maze1_walls = new ArrayList<Rectangle>();
+    //the arraylist storing all the maze1 walls
+    private ArrayList<Rectangle>  Maze1_walls;
 
 
     public void render_Maze1(Canvas canvas) {
-        width = canvas.getWidth();
-        height = canvas.getHeight();
         GraphicsContext gc = canvas.getGraphicsContext2D();
         gc.setFill(Color.BLACK);
+        //Drawing all the walls here
         gc.fillRect(width / 2 + 20, height - 30, width / 2 - 20, 30);
-        Maze1_walls.add(new Rectangle(width / 2 + 20, height - 30, width / 2 - 20, 30));
+        //And then adding them to the Maze1 array list so I can detect collisions for this maze later
+        gc.fillRect(width / 2 + 20, height - 50, 20, 30);
         gc.fillRect(0, height - 30, width / 2 - 20, 30);
-        Maze1_walls.add(new Rectangle(0, height - 30, width / 2 - 20, 30));
         gc.fillRect(width / 3, height / 2 + 50, width / 2, 30);
-        Maze1_walls.add(new Rectangle(width / 3, height / 2 + 50, width / 2, 30));
         gc.fillRect(0, height / 2, 30, height / 2);
-        Maze1_walls.add(new Rectangle(0, height / 2, 30, height / 2));
         gc.fillRect(width - 30, height / 2 - 50, 30, height / 2 + 50);
-        Maze1_walls.add(new Rectangle(width - 30, height / 2 - 50, 30, height / 2 + 50));
         gc.fillRect(width - 60, 3 * height / 4, 30, 10);
-        Maze1_walls.add(new Rectangle(width - 60, 3 * height / 4, 30, 10));
         gc.fillRect(width / 2 - 30, height / 4, 30, 200);
-        Maze1_walls.add(new Rectangle(width / 2 - 30, height / 4, 30, 200));
+
         gc.fillRect(width / 2, height / 4 + 100, 30, 10);
-        Maze1_walls.add(new Rectangle(width / 2, height / 4 + 100, 30, 10));
         gc.fillRect(0, height / 4, 250, 30);
-        Maze1_walls.add(new Rectangle(0, height / 4, 250, 30));
         gc.fillRect(2 * width / 3, height / 2 - 50, width / 2, 30);
-        Maze1_walls.add(new Rectangle(2 * width / 3, height / 2 - 50, width / 2, 30));
+
         gc.fillRect(width / 2 + 100, height / 4 - 30, 30, 10);
-        Maze1_walls.add(new Rectangle(width / 2 + 100, height / 4 - 30, 30, 10));
         gc.fillRect(width - 30, height / 4 - 30, 30, 10);
+
+    }
+    //So I only am adding to the arraylist once, instead of each time I render
+    public void save_Maze1(double Width, double Height){
+        width = Width;
+        height = Height;
+        Maze1_walls = new ArrayList<>();
         Maze1_walls.add(new Rectangle(width - 30, height / 4 - 30, 30, 10));
+        Maze1_walls.add(new Rectangle(width / 2 + 100, height / 4 - 30, 30, 10));
+        Maze1_walls.add(new Rectangle(2 * width / 3, height / 2 - 50, width / 2, 30));
+        Maze1_walls.add(new Rectangle(0, height / 4, 250, 30));
+        Maze1_walls.add(new Rectangle(width / 2, height / 4 + 100, 30, 10));
+        Maze1_walls.add(new Rectangle(width / 2 - 30, height / 4, 30, 200));
+        Maze1_walls.add(new Rectangle(width - 60, 3 * height / 4, 30, 10));
+        Maze1_walls.add(new Rectangle(width - 30, height / 2 - 50, 30, height / 2 + 50));
+        Maze1_walls.add(new Rectangle(0, height / 2, 30, height / 2));
+        Maze1_walls.add(new Rectangle(width / 3, height / 2 + 50, width / 2, 30));
+        Maze1_walls.add(new Rectangle(0, height - 30, width / 2 - 20, 30));
+        Maze1_walls.add(new Rectangle(width / 2 + 20, height - 50, 20, 30));
+        Maze1_walls.add(new Rectangle(width / 2 + 20, height - 30, width / 2 - 20, 30));
     }
 
-    public void check_collisions(Player player) {
+
+    public void check_collisions(Player ball) {
+
         for (Rectangle maze1_wall : Maze1_walls) {
             //checking for which direction the wall is, and changing the coordinates accordingly
             //wall on left
-            if (player.y < maze1_wall.getY() + maze1_wall.getHeight() &&
+
+            if (ball.y < maze1_wall.getY() + maze1_wall.getHeight() &&
                     //below top
-                    player.y > maze1_wall.getY() &&
+                    ball.y > maze1_wall.getY() &&
                     //left of right side
-                    player.x < maze1_wall.getX() + maze1_wall.getWidth() &&
+                    ball.x < maze1_wall.getX() + maze1_wall.getWidth() &&
                     //right of left side
-                    player.x > maze1_wall.getX() &&
-                    player.y + player.getWidth() < maze1_wall.getY() + maze1_wall.getHeight() &&
+                    ball.x > maze1_wall.getX() &&
+                    ball.y + ball.getWidth() < maze1_wall.getY() + maze1_wall.getHeight() &&
                     //below top
-                    player.y + player.getWidth() > maze1_wall.getY()){
-                player.x = maze1_wall.getX() + maze1_wall.getWidth();
+                    ball.y + ball.getWidth() > maze1_wall.getY()){
+                ball.x = maze1_wall.getX() + maze1_wall.getWidth();
+                if(ball instanceof Enemy_Blob){
+                    ball.bounce();
+                }
 
 
             }
 
             //wall right
-            if (player.y + player.getWidth() < maze1_wall.getY() + maze1_wall.getHeight() &&
+            if (ball.y + ball.getWidth() < maze1_wall.getY() + maze1_wall.getHeight() &&
                     //below top
-                    player.y + player.getWidth() > maze1_wall.getY() &&
+                    ball.y + ball.getWidth() > maze1_wall.getY() &&
                     //left of right side
-                    player.x + player.getWidth() < maze1_wall.getX() + maze1_wall.getWidth()&&
+                    ball.x + ball.getWidth() < maze1_wall.getX() + maze1_wall.getWidth()&&
                     //right of left side
-                    player.x + player.getWidth() > maze1_wall.getX() &&
-                    player.y < maze1_wall.getY() + maze1_wall.getHeight() &&
+                    ball.x + ball.getWidth() > maze1_wall.getX() &&
+                    ball.y < maze1_wall.getY() + maze1_wall.getHeight() &&
                     //below top
-                    player.y > maze1_wall.getY()
+                    ball.y > maze1_wall.getY()
                     //left of right side
 
             ){
-                player.x = maze1_wall.getX() - player.getWidth();
-
+                ball.x = maze1_wall.getX() - ball.getWidth();
+                if(ball instanceof Enemy_Blob){
+                    ball.bounce();
+                }
             }
             //bottom
-            if (player.x + player.getWidth() <= maze1_wall.getX() + maze1_wall.getWidth() &&
+            if (ball.x + ball.getWidth() <= maze1_wall.getX() + maze1_wall.getWidth() &&
                     //below top
-                    player.x + player.getWidth() >= maze1_wall.getX() &&
+                    ball.x + ball.getWidth() >= maze1_wall.getX() &&
                     //left of right side
-                    player.y + player.getWidth() < maze1_wall.getY() + maze1_wall.getHeight()&&
+                    ball.y + ball.getWidth() < maze1_wall.getY() + maze1_wall.getHeight()&&
                     //right of left side
-                    player.y + player.getWidth() > maze1_wall.getY() &&
-                    player.x <= maze1_wall.getX() + maze1_wall.getWidth() &&
+                    ball.y + ball.getWidth() > maze1_wall.getY() &&
+                    ball.x <= maze1_wall.getX() + maze1_wall.getWidth() &&
                     //below top
-                    player.x >= maze1_wall.getX()
+                    ball.x >= maze1_wall.getX())
                 //left of right side
-
-
-            ){
-                if(player.gravity){
-                    player.on_ground = true;
+                {
+                if(ball.gravity){
+                    ball.on_ground = true;
                 }
-                player.y = maze1_wall.getY() - player.getWidth();
-                player.jump = false;
-
-
+                ball.y = maze1_wall.getY() - ball.getWidth();
+                ball.jump = false;
             }
             //top
-            if (player.x + player.getWidth() <= maze1_wall.getX() + maze1_wall.getWidth() &&
+            if (ball.x + ball.getWidth() <= maze1_wall.getX() + maze1_wall.getWidth() &&
                     //below top
-                    player.x + player.getWidth() >= maze1_wall.getX() &&
+                    ball.x + ball.getWidth() >= maze1_wall.getX() &&
                     //left of right side
-                    player.y < maze1_wall.getY() + maze1_wall.getHeight()&&
+                    ball.y < maze1_wall.getY() + maze1_wall.getHeight()&&
                     //right of left side
-                    player.y > maze1_wall.getY() &&
-                    player.x <= maze1_wall.getX() + maze1_wall.getWidth() &&
+                    ball.y > maze1_wall.getY() &&
+                    ball.x <= maze1_wall.getX() + maze1_wall.getWidth() &&
                     //below top
-                    player.x >= maze1_wall.getX()
+                    ball.x >= maze1_wall.getX()
                 //left of right side
 
             ){
-                if(!player.gravity){
-                    player.on_ground = true;
+                if(!ball.gravity){
+                    ball.on_ground = true;
 
                 }
-                player.y = maze1_wall.getY() + maze1_wall.getHeight();
+
+                ball.y = maze1_wall.getY() + maze1_wall.getHeight();
 
             }
-            if(player.y == maze1_wall.getY() + maze1_wall.getHeight() && !player.gravity &&
-                    player.x < maze1_wall.getX() + maze1_wall.getWidth() &&
+            if(ball.y == maze1_wall.getY() + maze1_wall.getHeight() && !ball.gravity &&
+                    ball.x < maze1_wall.getX() + maze1_wall.getWidth() &&
                     //below top
-                    player.x > maze1_wall.getX() &&
-                    player.x + player.getWidth() < maze1_wall.getX() + maze1_wall.getWidth() &&
+                    ball.x > maze1_wall.getX() &&
+                    ball.x + ball.getWidth() < maze1_wall.getX() + maze1_wall.getWidth() &&
                     //below top
-                    player.x + player.getWidth() > maze1_wall.getX()
+                    ball.x + ball.getWidth() > maze1_wall.getX()
                 //left of right side
             ){
-                player.on_ground = true;
+                ball.on_ground = true;
 
             }
-            if(player.y + player.getWidth() == maze1_wall.getY() && player.gravity &&
-                    player.x < maze1_wall.getX() + maze1_wall.getWidth() &&
+            if(ball.y + ball.getWidth() == maze1_wall.getY() && ball.gravity &&
+                    ball.x < maze1_wall.getX() + maze1_wall.getWidth() &&
                     //below top
-                    player.x > maze1_wall.getX() &&
-                    player.x + player.getWidth() < maze1_wall.getX() + maze1_wall.getWidth() &&
+                    ball.x > maze1_wall.getX() &&
+                    ball.x + ball.getWidth() < maze1_wall.getX() + maze1_wall.getWidth() &&
                     //below top
-                    player.x + player.getWidth() > maze1_wall.getX()){
-                player.on_ground = true;
+                    ball.x + ball.getWidth() > maze1_wall.getX()){
+                ball.on_ground = true;
 
             }
-
-
         }
     }
-
+    //TODO MOVE THIS TO THE PLAYER TAB WHY IS IT IN THE MAZE TAB
     public void falling(Player player){
-
         if(!player.on_ground && !player.jump && player.gravity){
             player.y += 4;
+
         } else if(!player.on_ground && !player.jump){
             player.y -= 2;
         }
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ProjectKey\">\n    <option name=\"state\" value=\"project://e79810c8-c5c8-43b1-b19c-90c1f4095425\" />\n  </component>\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_15\" default=\"true\" project-jdk-name=\"openjdk-15\" project-jdk-type=\"JavaSDK\">\n    <output url=\"file://$PROJECT_DIR$/out\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision 4279333957e134dfb023dc1192d2f9067d52f0fe)
+++ b/.idea/misc.xml	(date 1620160936570)
@@ -3,7 +3,7 @@
   <component name="ProjectKey">
     <option name="state" value="project://e79810c8-c5c8-43b1-b19c-90c1f4095425" />
   </component>
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_15" default="true" project-jdk-name="openjdk-15" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_14" default="true" project-jdk-name="14" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/out" />
   </component>
 </project>
\ No newline at end of file
Index: src/org/alecs2023/designproject/goal.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/org/alecs2023/designproject/goal.java b/src/org/alecs2023/designproject/goal.java
new file mode 100644
--- /dev/null	(date 1620159067215)
+++ b/src/org/alecs2023/designproject/goal.java	(date 1620159067215)
@@ -0,0 +1,5 @@
+package org.alecs2023.designproject;
+
+public class goal {
+
+}
